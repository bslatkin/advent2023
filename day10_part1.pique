"""
depth first search
start with adjacent pipes n/s/e/w
check if they are properly aligned or skip
add them to the queue to be investigated
write down their distance, but connected state is none
also record the path that it takes to get to each node
when you find the S again after going through the loop, you'll have the whole loop history and can then terminate with all of the node IDs
do another pass through node coordiantes to find max distance number
"""

import "advent"
import "functional"
import "list"


struct position (coords pipe)


struct transition (direction to)


def get-grid (grid coords)
  return dict.get-or-default grid coords nil


def get-grid-offset (grid coords offset-x offset-y)
  let adjusted-coords =
    list
      add (first coords) offset-x
      add (list.second coords) offset-y

  return get-grid grid adjusted-coords


let NORTHWARD = "NORTH"
let EASTWARD = "EAST"
let SOUTHWARD = "SOUTH"
let WESTWARD = "WEST"


def get-neighbors (grid coords)
  let north = get-grid-offset grid coords 0 -1
  let east = get-grid-offset grid coords 1 0
  let south = get-grid-offset grid coords 0 1
  let west = get-grid-offset grid coords -1 0
  let all-directions =
    list
      if north then (transition (direction = NORTHWARD) (to = north))
      if east then (transition (direction = EASTWARD) (to = east))
      if south then (transition (direction = SOUTHWARD) (to = south))
      if west then (transition (direction = WESTWARD) (to = west))
  let valid = filter bool all-directions
  return valid


let SUCCESSORS =
  dict.from-list
    list
      list EASTWARD (list "J" "-" "7")
      list WESTWARD (list "F" "-" "L")
      list NORTHWARD (list "F" "|" "7")
      list SOUTHWARD (list "J" "|" "L")


def is-successor (previous-pipe direction)
  let valid = dict.get SUCCESSORS direction
  print "checking successor for" direction previous-pipe "in" valid
  return list.contains valid previous-pipe


def has-start (neighbors)
  def check (item)
    let ignore next-position = item
    return equal (position-pipe next-position) "S"

  return filter check neighbors



def step-one (grid distances seen coords pipe distance)


  let transitions = get-neighbors grid coords

  if loop-closed seen coords distance then

  if and (greater-than distance 2) (dict.contains seen

  # check for start

  let new-ground =
    filter
      lambda neighbor: not (dict.contains seen (transition-to neighbor))
      transitions

  let valid =
    filter
      lambda neighbor: is-successor pipe (transition-direction neighbor)
      new-ground

  if not valid then
    print "Dead end"
    return nil

  if not-equal (list.length valid) 1 then
    print "Found positions" valid
    raise "Only one valid next position should be possible"

  let next-move = first valid
  let next-coords = transition-to next-move
  let next-pipe = dict.get grid next-coords
  let next-distance = add distance 1
  let next-seen = dict.set next-coords next-distance
  return step-one grid seen next-coords next-pipe next-distance


def codepoint-iter (the-string)
  let indexes = range (strlen the-string)
  let codepoints =
    map
      lambda i: substr the-string i (add i 1)
      indexes
  return codepoints


def parse-line (y line)
  let codepoints = codepoint-iter line
  let positions =
    functional.map-index
      lambda x pipe: if not-equal pipe "." then (list (list x y) pipe) else nil
      codepoints
  let valid = filter bool positions
  return valid


def main (args)
  let data = (advent.read-all)
  let rows = functional.map-index parse-line data
  let grid =
    functional.fold
      lambda state items: dict.update-items state items
      rows
      (dict.new)

  let start-position =
    position
      coords = list 1 1
      pipe = "S"

  let neighbors = get-neighbors grid start-position
  let attempt = transition-to (first neighbors)
  print "trying" attempt

  let result =
    step-one
      grid
      dict.from (list (position-coords attempt) 1)
      attempt
  print result

  return 0



# def search-one (grid start-coords)
#   let start-position =
#     position
#       coords = start-coords
#       pipe = get-grid start-coords

#   return step-one grid (list start-position)





