"""
depth first search
start with adjacent pipes n/s/e/w
check if they are properly aligned or skip
add them to the queue to be investigated
write down their distance, but connected state is none
also record the path that it takes to get to each node
when you find the S again after going through the loop, you'll have the whole loop history and can then terminate with all of the node IDs
do another pass through node coordiantes to find max distance number
"""

import "advent"
import "functional"
import "list"
import "sort"


struct position (coords pipe)


struct transition (direction to)


def get-grid (grid coords)
  return dict.get-or-default grid coords nil


def offset-coords (coords offset-x offset-y)
  let adjusted-coords =
    list
      add (first coords) offset-x
      add (list.second coords) offset-y
  return adjusted-coords



let NORTHWARD = "NORTH"
let EASTWARD = "EAST"
let SOUTHWARD = "SOUTH"
let WESTWARD = "WEST"


def get-neighbors (grid coords)
  let all-directions =
    list
      transition (direction = NORTHWARD) (to = offset-coords coords 0 -1)
      transition (direction = EASTWARD) (to = offset-coords coords 1 0)
      transition (direction = SOUTHWARD) (to = offset-coords coords 0 1)
      transition (direction = WESTWARD) (to = offset-coords coords -1 0)

  let valid =
    filter
      lambda neighbor: not-equal (get-grid grid (transition-to neighbor)) nil
      all-directions

  return valid


let SUCCESSORS =
  dict.from-list
    list
      list EASTWARD (list "F" "-" "L")
      list WESTWARD (list "J" "-" "7")
      list NORTHWARD (list "J" "|" "L")
      list SOUTHWARD (list "F" "|" "7")
    #   list EASTWARD (list "J" "-" "7")
    #   list WESTWARD (list "F" "-" "L")
    #   list NORTHWARD (list "F" "|" "7")
    #   list SOUTHWARD (list "J" "|" "L")


def is-successor (previous-pipe direction)
  if equal previous-pipe "S" then
    return true
  let valid = dict.get SUCCESSORS direction
  print "checking successor for" direction previous-pipe "in" valid
  return list.contains valid previous-pipe


def minimize-keys (current new)
  return
    functional.fold
      def helper (state item)
        let key value = item
        let previous = dict.get-or-default state key nil
        if equal previous nil then
          return dict.set state key value

        let lowest = min value previous
        return dict.set state key lowest
      dict.items new
      current


def step-one (grid seen coords)
  let transitions = get-neighbors grid coords
  let pipe = get-grid grid coords
  let distance = dict.get seen coords
  print "Trying" coords pipe "at" distance

  let loop-closed =
    if greater-than distance 1 then
      list.any-test
        lambda neighbor: equal (get-grid grid (transition-to neighbor)) "S"
        transitions
      else
      false

  if loop-closed then
    print "Closed the loop after" distance
    return seen

  let new-ground =
    filter
      lambda neighbor: not (dict.contains seen (transition-to neighbor))
      transitions

  let valid =
    filter
      lambda neighbor: is-successor pipe (transition-direction neighbor)
      new-ground

  if not valid then
    print "Dead end"
    return nil

  def mover (next-move)
    let next-coords = transition-to next-move
    let next-pipe = get-grid grid next-coords
    let next-distance = add distance 1
    print "Moving from" coords pipe "to" next-coords next-pipe
    let next-seen = dict.set seen next-coords next-distance
    return step-one grid next-seen next-coords

  if equal (list.length valid) 1 then
    return mover (first valid)

  print "Multiple moves" valid

  # Multiple branches!
  let all-seen = map mover valid

  let minimums =
    functional.fold
      minimize-keys
      all-seen
      (dict.new)

  return minimums


def codepoint-iter (the-string)
  let indexes = range (strlen the-string)
  let codepoints =
    map
      lambda i: substr the-string i (add i 1)
      indexes
  return codepoints


def parse-line (y line)
  let codepoints = codepoint-iter line
  let positions =
    functional.map-index
      lambda x pipe: if not-equal pipe "." then (list (list x y) pipe) else nil
      codepoints
  let valid = filter bool positions
  return valid


def find-start-coords (grid)
  let found =
    map
      def helper (item)
        let coords value = item
        if equal value "S" then
          return coords
          else
          return nil
      dict.items grid
  let valid = filter bool found
  if not valid then
    raise "Could not find starting point"
  return first valid


def main (args)
  let data = (advent.read-all)
  let rows = functional.map-index parse-line data
  let grid =
    functional.fold
      lambda state items: dict.update-items state items
      rows
      (dict.new)

  let coords = find-start-coords grid

  let result =
    step-one
      grid
      dict.from (list coords 0)
      coords

  let inverted =
    map
    def helper (item)
      let key value = item
      return list value key
    dict.items result

  let sorted = sort.sort-with-compare sort.descending inverted
  let top = first sorted
  print top

  return 0
