"""
depth first search
start with adjacent pipes n/s/e/w
check if they are properly aligned or skip
add them to the queue to be investigated
write down their distance, but connected state is none
also record the path that it takes to get to each node
when you find the S again after going through the loop, you'll have the whole loop history and can then terminate with all of the node IDs
do another pass through node coordiantes to find max distance number
"""

import "advent"
import "functional"
import "list"


struct position (coords pipe)


def get-grid (grid coords)
  let pipe = dict.get-or-default grid coords nil
  if not pipe then
    return nil

  return position
    coords = coords
    pipe = pipe


def get-grid-offset (grid coords offset-x offset-y)
  let adjusted-coords =
    list
      add (first coords) offset-x
      add (list.second coords) offset-y

  return get-grid grid adjusted-coords


let NORTHWARD = "NORTH"
let EASTWARD = "EAST"
let SOUTHWARD = "SOUTH"
let WESTWARD = "WEST"


def get-neighbors (grid current-position)
  let coords = position-coords current-position
  let north = get-grid-offset grid coords 0 -1
  let east = get-grid-offset grid coords 1 0
  let south = get-grid-offset grid coords 0 1
  let west = get-grid-offset grid coords -1 0
  let all-directions =
    list
      if north then (list NORTHWARD north)
      if east then (list EASTWARD east)
      if south then (list SOUTHWARD south)
      if west then (list WESTWARD west)
  let valid = filter bool all-directions
  return valid


let SUCCESSORS =
  dict.from-list
    list
      list EASTWARD (list "J" "-" "7")
      list WESTWARD (list "F" "-" "L")
      list NORTHWARD (list "F" "|" "7")
      list SOUTHWARD (list "J" "|" "L")

      # list EASTWARD (list "L" "-" "F")
      # list WESTWARD (list "J" "-" "7")
      # list NORTHWARD (list "J" "|" "L")
      # list SOUTHWARD (list "7" "|" "F")


def is-successor (direction current)
  let valid = dict.get SUCCESSORS direction
  print "checking successor for" direction current "in" valid
  return list.contains valid (position-pipe current)


def fit-neighbor (seen neighbors current-position)
  def filter-one (item)
    let direction next-position = item

    if equal next-position current-position then
      return false

    if not (is-successor direction next-position) then
      return false

    return true

  let new-ground = filter filter-one neighbors

  if not new-ground then
    print "Dead end"
    return nil

  if not-equal (list.length new-ground) 1 then
    print "Found positions" new-ground
    raise "Only one valid next position should be possible"

  return first new-ground


def has-start (neighbors)
  def check (item)
    let ignore next-position = item
    return equal (position-pipe next-position) "S"

  return filter check neighbors


def save-distance (seen current-position current-distance)
  let coords = position-coords current-position
  let previous-distance = dict.get-or-default seen coords nil

  if
    or
      equal previous-distance nil
      less-than current-distance previous-distance
    then
    return dict.set seen coords current-distance
    else
    return seen


def step-one (grid seen current-position current-distance)
  let neighbors = get-neighbors grid current-position

  if and (greater-equal current-distance 3) (has-start neighbors) then
    return seen

  let next-position = fit-neighbor seen neighbors current-position
  if not next-position then
    return nil

  print "found next position" next-position
  let next-x = list.second next-position

  let next-distance = add current-distance 1
  let next-seen = save-distance seen next-x next-distance
  return step-one grid next-seen next-x next-distance


def codepoint-iter (the-string)
  let indexes = range (strlen the-string)
  let codepoints =
    map
      lambda i: substr the-string i (add i 1)
      indexes
  return codepoints


def parse-line (y line)
  let codepoints = codepoint-iter line
  let positions =
    functional.map-index
      lambda x pipe: if not-equal pipe "." then (list (list x y) pipe) else nil
      codepoints
  let valid = filter bool positions
  return valid


def main (args)
  let data = (advent.read-all)
  let rows = functional.map-index parse-line data
  let grid =
    functional.fold
      lambda state items: dict.update-items state items
      rows
      (dict.new)

  let start-position =
    position
      coords = list 1 1
      pipe = "S"

  let start-neighbors = get-neighbors grid start-position
  let first-neighb = list.second (first start-neighbors)
  print "trying" first-neighb

  let result =
    step-one
      grid
      dict.from (list (position-coords first-neighb) 1)
      first-neighb
      0
  print result

  return 0



# def search-one (grid start-coords)
#   let start-position =
#     position
#       coords = start-coords
#       pipe = get-grid start-coords

#   return step-one grid (list start-position)





