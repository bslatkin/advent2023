import "struct"
import "functional"
import "list"


struct matrix (rows columns transposed data)


def rectangular-items (rows)
  let items =
    functional.map-index
      lambda row-i row:
        functional.map-index
          lambda column-j value: list (list row-i column-j) value
          row
      rows
  let flat-items = list.extend-lists items
  return flat-items


def matrix-from-list (rows)
  if not rows then
    raise "Must have at least one row"

  return
    matrix
      rows = list.length rows
      columns = list.length (first rows)
      transposed = false
      data = dict.from-list (rectangular-items rows)


def adjusted-rows (collection)
  if matrix-transposed collection then
    return matrix-columns collection
    else
    return matrix-rows collection


def adjusted-columns (collection)
  if matrix-transposed collection then
    return matrix-rows collection
    else
    return matrix-columns collection


def adjusted-coords (collection coords)
  if matrix-transposed collection then
    return list.reverse coords
    else
    return coords


def matrix-get (collection coords)
  let adjusted = adjusted-coords collection coords
  return dict.get (matrix-data collection) adjusted


def row-coordinates (row-index column-count)
  return
    map
      lambda column-i: list row-index column-i
      range column-count


def column-coordinates (row-count column-index)
  return
    map
      lambda row-i: list row-i column-index
      range row-count


def all-coords (row-count column-count)
  let rows = range row-count
  let columns = range column-count
  let coords =
    map
      lambda row-i:
        map
          lambda column-j: list row-i column-j
          columns
      rows
  let flattened = list.extend-lists coords
  return flattened


def matmul (left right)
  let left-row-count = adjusted-rows left
  let left-column-count = adjusted-columns left
  let right-row-count = adjusted-rows right
  let right-column-count = adjusted-columns right

  if not-equal left-column-count right-row-count then
    raise "Matrices aren't compatible shapes"

  let get-left = functional.partial matrix-get left
  let get-right = functional.partial matrix-get right

  def compute-element (coord)
    let row-i column-j = coord
    let row-coords = row-coordinates row-i left-column-count
    let column-coords = column-coordinates right-row-count column-j
    let row-values = map get-left row-coords
    let column-values = map get-right column-coords
    let multiplied = map mul row-values column-values
    let total = sum multiplied
    return list coord total

  let result-coords = all-coords left-row-count right-column-count
  let assignments = map compute-element result-coords
  return
    matrix
      rows = left-row-count
      columns = right-column-count
      transposed = false
      data = dict.from-list assignments


def matrix-transpose (collection)
  let next-transposed = not (matrix-transposed collection)
  return matrix-set-transposed collection next-transposed


def vector (row)
  let surround = list row
  return
    matrix
      rows = 1
      columns = list.length row
      transposed = false
      data = dict.from-list (rectangular-items surround)


def dot-product (left right)
  let right-t = matrix-transpose right
  return matmul left right-t


def main (args)
  let a = matrix-from-list (list (list 1 2) (list 3 4))
  print a
  print
    matrix-get a (list 0 0)
    matrix-get a (list 0 1)
    matrix-get a (list 1 0)
    matrix-get a (list 1 1)
  let b = matrix-from-list (list (list 5 6) (list 7 8))
  print b
  let c = matmul a b
  print c
  let d = matrix-transpose b
  print d
  let e = matmul a d
  print e

  let v1 = vector (list 1 2 3)
  let v2 = vector (list 4 5 6)
  let dot = dot-product v1 v2
  print v1 v2 dot

  return 0
